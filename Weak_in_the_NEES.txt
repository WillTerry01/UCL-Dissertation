Weak in the NEES?: Auto-tuning Kalman Filters
with Bayesian Optimization

arXiv:1807.08855v1 [stat.ML] 23 Jul 2018

Zhaozhong Chen, Christoffer Heckman

Simon Julier

Department of Computer Science
Department of Computer Science
University of Colorado Boulder
University College London
430 UCB
66–72 Gower Street,
Boulder, CO 80309
London WC1E 6BT, UK
email: Christoffer.Heckman@colorado.edu
email: s.julier@ucl.ac.uk

Abstract—Kalman filters are routinely used for many data
fusion applications including navigation, tracking, and simultaneous localization and mapping problems. However, significant time
and effort is frequently required to tune various Kalman filter
model parameters, e.g. process noise covariance, pre-whitening
filter models for non-white noise, etc. Conventional optimization
techniques for tuning can get stuck in poor local minima and
can be expensive to implement with real sensor data. To address
these issues, a new “black box” Bayesian optimization strategy
is developed for automatically tuning Kalman filters. In this
approach, performance is characterized by one of two stochastic
objective functions: normalized estimation error squared (NEES)
when ground truth state models are available, or the normalized innovation error squared (NIS) when only sensor data is
available. By intelligently sampling the parameter space to both
learn and exploit a nonparametric Gaussian process surrogate
function for the NEES/NIS costs, Bayesian optimization can
efficiently identify multiple local minima and provide uncertainty
quantification on its results.

I. I NTRODUCTION
Although research in the past few years has introduced many
new estimation algorithms, the Kalman filter still remains one
of the most widely used algorithms in the world today. Its
popularity can largely be attributed to its efficiency, simplicity
and robustness.
A major challenge in developing a Kalman filter is that it
must be tuned. Given a real world application and a system
design, the process and observation covariance matrices must
be set to given an acceptable level of performance. This
performance is often defined in terms of the mean squared
error of the estimate. The general idea behind tuning is to
search over the space of filter parameters and assess performance. If one has access to ground truth (either from an extra
measurement system or simulation), the performance can be
assessed statistically based on the normalized estimation error
squared (NEES). However, often only observation sequences
are available and thus the normalized innovation squared (NIS)
must be used instead. Tuning then becomes a problem of
balancing the behaviour of the filter performance metric over
time. One approach is to do this manually, i.e. simply explore
over all available degrees of freedom until good results obtained. However, this can often be a long and difficult process

Nisar Ahmed
Smead Aerospace Engineering Sciences
University of Colorado Boulder
429 UCB
Boulder, CO 80309
email: Nisar.Ahmed@colorado.edu

which requires studying the interaction of many different filter
parameters.
Given the difficulty of manual tuning, methods for automating filter tuning are of great practical interest. These
methods typically pose tuning as an optimisation problem:
given a measure of performance, such as NIS and NEES,
iterate through points in parameter space to find the one which
provides the best results. These can give very good results.
However, a key issue is that the optimisation problem is often
highly non-covex. As a result, gradient-based optimization
algorithms suffer from the possibility that they could fall into
a local minima.
In this paper, we consider the problem of how to develop
Kalman filter tuning algorithm using Bayesian Optimization.
Our idea is to recast optimization as a Bayesian search problem
in which the next iteration of the optimizer seeks a point
which maximizes the probability of improving an overall
measure of the state estimator performance. As such, Bayesian
optimization offers a potentially principled way to handle
the local minima problem. For this initial investigation, we
restrict ourselves to linear systems. However, the underlying
principles apply to nonlinear systems as well and are amenable
to extension covering these cases.
This paper is structured as follows. Section II introduces
the filter tuning problem. Section III provides an overview
of Bayesian optimization using Gaussian process models for
optimizing stochastic black box cost functions, and then
describes its novel application to Kalman filter tuning using
cost functions based on χ2 consistency test statistics. Section IV presents numerical examples showing the application
of Bayesian optimization auto-tuning to a linear system. Conclusions and ongoing/ future work are given in Section V.
II. P RELIMINARIES
A. System Description
Consider the problem of estimating the state and quantifying
the uncertainty in that estimate in discrete time. Let the state
of the system at time step k be xk ; our goal is to develop an
algorithm that can result in the state estimate. Let x̂i|j be the

estimate of xi using all observations up to time step j, and
the covariance of this estimate be Pi|j :
x̂i|j = E [xi |z1:j ]
h
i


⊤
Pi|j = E xi − x̂i|j |z1:j xi − x̂i|j |z1:j .

(1)

xk = Fk xk−1 + Bk uk + vk ,

(3)

(2)

The system is described by a process model and an observation model. The process model that describes how the system
evolves from state k − 1 to k is:
where uk is the control input and vk is the process noise,
which is assumed to be zero mean and independent with
covariance Qk . The observation model is
zk = Hk xk + wk ,

(17)

ǫx,k = eTx,k P−1
k|k ex,k

(18)

(7)

ǫz,k = eTz,k S−1
k|k−1 ez,k ,

(19)

(8)

which define the normalized estimation error squared (NEES)
and normalized innovation error squared (NIS), respectively.
If the dynamical consistency conditions are met, then it is easy
to show that ǫx,k and ǫz,k should be χ2 random variables with
nx and nz degrees of freedom, respectively [2]. Therefore, χ2
hypothesis tests can be performed on calculated values for
ǫx,k (when ground truth data is available) and ǫz,k to see if
the consistency conditions hold at each time k.
In practice, NEES χ2 tests are conducted using multiple
offline Monte Carlo ‘truth model’ simulations to obtain ground
truth xk values. The truth model simulator represents a highfidelity model of the ‘actual’ system dynamics and sensor
observations, which may contain non-linearities and other nonideal characteristics that must be compensated for via Kalman
filter tuning. NIS χ2 can be conducted offline using multiple
Monte Carlo simulations (e.g. in parallel with NEES tests),
but can also be conducted online with real sensor data logs.
Offline truth model tests are conducted as follows 1 : suppose N independent instances of the true state are randomly
initialized according to x̂0|0 and P0|0 (the initial state of
the filter), and then propagated through the true stochastic
dynamics (3) and measurement model (4) for T time steps,
yielding sample ground truth sequences xi1 , xi2 , . . . , xiT and
measurement sequences zi1 , zi2 , . . . , ziT for i = 1, . . . , N . If
the resulting measurement sequences are then fed to a Kalman
filter with tuning parameters (Qk , Rk ), the resulting NEES

x̂k|k−1 = Fk x̂k−1|k−1 + Bk uk

(5)

Pk|k−1 = Fk Pk−1|k−1 F⊤
k + Qk

(6)

while the update is given by
Pk|k = Pk|k−1 − Kk Sk|k−1 K⊤
k,
⊤
Sk|k−1 = Hk Pk|k−1 Hk + Rk
−1
Kk = Pk|k−1 H⊤
k Sk|k−1

(9)
(10)

where ez,k = ẑk|k−1 − zk is the so-called innovation vector.
A dynamical state estimator is statistically consistent if the
following conditions are met [2]:
1) the state estimation errors are unbiased,
E [ex,k ] = 0, ∀k
2) the estimator is efficient,


E ex,k eTx,k = Pk|k , ∀k

(11)

(12)

3) the innovations form a white Gaussian sequence, such
that for all times k and j,
ez,k ∼ N (0, Sk|k−1 )

E [ez,k ] = 0,


E ez,k eTz,j = δjk · Sk|k−1

Filter tuning is the process of selecting parameters to optimize performance. Consistency ensures two desirable properties in a Kalman filter: (i) the filter is ‘aware’ of how wrong
it could actually be; and (ii) the filter blends the right amount
of information from its process model and measurements to
recursively correct its state estimate.
Given values for Fk and Hk , tuning involves choosing Qk
and Rk . If the model is matched (Fk and Hk are the same as
the true system), the statistical consistency can be achieved.
However, in general the model can be mismatched. In this
case, we seek to satisfy the weaker condition of covariance
consistency,
x̂i|j ≈ E [xi |z1:j ]
i
h


⊤
Pi|j ≥ E xi − x̂i|j |z1:j xi − x̂i|j |z1:j .

(4)

where wk is the observation noise. This is assumed to be
zero-mean and independent with a covariance Rk .
As is well-known, a Kalman filter may be applied to this
problem in order to find the optimal estimate [1]; this filter
follows a two stage process of prediction followed by update.
The predicted state is given by

x̂k|k = x̂k|k + Kk ez,k ,

B. Filter Tuning

(13)
(14)
(15)

Intuitively, a filter is statistically consistent if it correctly
describes the actual state error statistics for any set of (simulated) ground truth state sequences, as well as correctly
describes the actual measurement residual errors for any set
of measurement data logs. When the full structure of the
system state (Fk , Hk , Qk and Rk ) is known, the Kalman
filter equations automatically guarantee statistical consistency.
However, in many situations the model is not known precisely,
and so the filter must be tuned.

(16)

where ≈ is application specific and A ≥ B means that
A − B is positive semidefinite. In other words, the estimate
should be approximately unbiased, and the estimator should
not over estimate its level of confidence. At the same time,
the estimated covariance should not be very large.
These conditions can be assessed by examining the normalized scalar magnitudes of the random variables ex,k and ez,k ,

1 Online NIS tests with real sensor data are similar, but exploit ergodicity
of measurement innovation sequences

and NIS statistics for each simulation run i at each time k can
be averaged across problem instances to give the test statistics

III. BAYESIAN O PTIMIZATION FOR F ILTER AUTO - TUNING

A common approach to solving nonlinear optimization
problems
is to use gradient descent. However, the risk with
N
1 X i
these
approaches
is that they can fall into local minima. This
ǫ
(20)
ǭx,k =
N i=1 x,k
issue is exacerbated for filter tuning problems where objective
functions are governed by noisy dynamical systems. With
N
1 X i
ǭz,k =
ǫ .
(21) a finite number of samples, stochastic variation introduces
N i=1 z,k
many small local minima and maxima which can trap gradient
descent methods. One principled way to handle parameter
Then, given some desired Type I error rate α, the NEES tuning problems in such cases is to use Bayesian Optimization
and NIS χ2 tests provide lower and upper tail bounds which poses optimization as a Bayesian search problem. The
[lx (α, N ), ux (α, N )] and [lz (α, N ), uz (α, N )], such that the objective function is unknown and is treated as a random
Kalman filter tuning is declared to be consistent if, with variable. A prior is placed over it. As the algorithm proceeds,
probability 100(1 − α) at each time k,
each iteration takes samples from the objective function which
are used to refine the distribution. The next sample point is
ǭx,k ∈ [lx (α, N ), ux (α, N )] and ǭz,k ∈ [lz (α, N ), uz (α, N )]. selected to maximize the probability of improving the current
best estimate.
Otherwise, the filter is declared to be inconsistent. Specifically,
First we will describe Bayesian optimization for dealif ǭx,k < lx (α, N ) or ǭz,k < lz (α, N ), then the filter tuning ing with generic ‘black box’ stochastic objective functions.
is ‘pessimistic’ (‘underconfident’), since the filter-estimated We then describe its novel application for simulation-based
state error/innovation covariances are too large relative to Kalman filter auto-tuning.
the true values. On the other hand, if ǭx,k > ux (α, N ) or
ǭz,k > uz (α, N ), then the filter tuning is ‘optimistic’ (‘over- A. Bayesian Optimization Theory
confident’), since the filter-estimated state error/innovation
Consider the minimization of some objective function y :
covariance are too small relative to the true values.
Q → R, where Q ∈ Rd is the search or solution space, and
The χ2 consistency tests provide a very principled basis the element q∗ ∈ Q is the minimizer, such that y(Q∗ ) ≤
for validating Kalman filter performance in domain-agnostic y(Q), ∀q ∈ Q. For simplicity, we assume the solution space is
way, and also provide a well-established means for guiding the bounded for global optimization, where Q(i) ∈ [q(i)l , q(i)u ]
tuning of noise parameters Qk and Rk in practical applica- for lower bound q(i)l and upper bound q(i)u for element i of
tions. Tuning via the χ2 tests is most often done manually, and q. When the mapping from q to y is not known explicitly, the
thus requires repeated ‘guessing and checking’ over multiple optimization typically requires the evaluation of a ‘black box’
Monte Carlo simulation runs. However, this quickly becomes function. In our application, y is the result of evaluating the
cumbersome and non-trivial for systems with several tunable performance of a Kalman filter in design configuration q on
noise terms. Heuristics for manual filter tuning have been a set of synthetic/real sensor data logs generated by a ‘true’
developed in the linear-quadratic optimal control literature [3], underlying dynamical system. The black box evaluations of
e.g. to coarsely tune diagonals of Qk first, before fine-tuning y can therefore be expensive, slow, and produce noisy results
the elements of Qk further. Such heuristics are useful for for the same input q.
bounding the shape and magnitude of Qk in linear-Gaussian
The goal of Bayesian optimization is to find the minimizer
problems, but are of little help for tuning ‘fudge factor’ process of a noisy objective function y that is costly to evaluate at any
noise parameters that are used to cope with model errors given design point q, while also learning about the mapping
from state truncation, approximations of non-linearities, poorly from q to y at the same time via Bayesian inference. An initial
modeled dynamics, etc.
prior belief p(y) over possible y functions is updated by subseManual tuning is especially challenging if truth model quent observations (evidence) E consisting of sample y evalsimulations are computationally expensive to run or the filter uations for different sampled q values. Mathematically, this
involves many parameters which can interact with one another leads to an application of Bayes’ rule: p(y|E) ∝ p(E|y)p(y),
in subtle and surprising ways. This not only also makes it where p(E|y) is the observation likelihood and p(y|E) is the
difficult to explore the parameter space to properly calibrate posterior of y given E. Hence, evidence E gives information
heuristics, but also makes it difficult to achieve a large enough about the actual shape of y, allowing the posterior belief about
N to properly assess inherently noisy NEES/NIS test statistics. the assumed shape of y to be recursively updated. As long as
Furthermore, because the NEES and NIS are outputs of a both p(y) and p(y|E) are consistent with the true nature of
stochastic non-differentiable ‘black box’ simulation function, y, then the law of large numbers ensures that the posterior
the filter tuning process cannot be simply automated via p(y|E) converges with high probability to the true y, in the
conventional convex optimization methods (e.g. line search, limit of infinite observations E covering Q.
gradient descent, etc.). Given this, we need to use alternative
Bayesian optimization uses black box point evaluations of
optimization techniques which are robust to stochastic varia- y to efficiently find q∗ . This is accomplished by maintaining
tions in the cost function and can explore nonlinear spaces.
beliefs about how y behaves over all q in the form of a

“surrogate model” S, which statistically approximates y and
is easier to evaluate (e.g. since y might be an expensive
high fidelity simulation). During optimization, S is used to
determine where the next design point sample evaluation
of y should occur, in order to update beliefs over y and
thus simultaneously improve S while finding the (expected)
minimum of y as quickly as possible. The key idea is that,
as more observations are sampled at different q locations,
the q samples themselves eventually converge to the expected
minimizer q∗ of y. Since S contains statistical information
about the level of uncertainty in y (i.e. related to p(y|E), the
posterior belief), Bayesian optimization effectively leverages
probabilistic ‘explore-exploit’ behavior to learn an approximate model of y while also minimizing it. We next describe the
two main components of the Bayesian optimization process:
(1) the surrogate model S, which encodes statistical beliefs
about y in light of previous observations and a prior belief; and
(2) the acquisition function a(q), which is used to intelligently
guide the search for q∗ via S.
1) The Surrogate Model: S must approximate y in areas
where it has not yet been evaluated, and must also provide
a predicted value and corresponding uncertainty to quantify
the possibility that the optimum is located at some location q.
Gaussian Processes (GPs) [4] are the most common family of
surrogate models used in Bayesian optimization; the acronym
GPBO here refers to Bayesian optimization using a GP surrogate model S. A GP describes a distribution over functions; it
is more formally defined as a collection of random variables,
any finite number of which have a joint Gaussian distribution
[5], [4],
f (q) ∼ GP(m(q), k(q, q′ ))

m(q) = E[f (q)]
k(q, q′ ) = E[(f (q) − m(q))(f (q′ ) − m(q′ ))]

(22)
(23)
(24)

where the process is completely specified by its mean function
m(q) (equation 23), and its covariance function k(q, q′ )
(equation 24). In theory m(q) could be any function; as is
common practice, this work assumes m is zero for simplicity.
The covariance (or kernel) function is a mapping k : (q, q′ ) →
R; this must be specified a priori, and is usually based on some
knowledge of y’s smoothness properties.
A valid kernel must be positive semi-definite (PSD), i.e.
it must produce a Gram matrix K, with individual elements
[Ki,j ] given by k(qi , qj ), that is PSD given a set of training
data Q = {q1 , . . . , qn }. Let K(Q, Q) be the Gram matrix
defined by kernel function k,


k(q1 , q1 ) k(q1 , q2 ) · · · k(q1 , qn )
 k(q2 , q1 ) k(q2 , q2 ) · · · k(q2 , qn ) 


K(Q, Q) = 
.
..
..
..


.
.
.
k(qn , q1 ) k(qn , q2 ) · · · k(qn , qn )

(25)

Given n training observations, the elements of the covariance matrix K(Q, Q) ∈ Rn×n are the covariances k(qi , qj )
between qi and qj for all pairs of training data. The joint

distribution of n training outputs f (Q) ∈ Rn×1 and p test
outputs f ∗ (Q∗ ) ∈ Rp×1 for inputs Q∗ = {q∗1 , . . . , q∗p } is
 

 
K(Q, Q) K(Q, Q∗ )
f
∼ N 0,
,
(26)
K(Q∗ , Q) K(Q∗ , Q∗ )
f∗


k(q∗1 , q1 ) k(q∗1 , q2 ) · · · k(q∗1 , qn )
k(q∗2 , q1 ) k(q∗2 , q2 ) · · · k(q∗2 , qn )


K(Q∗ , Q) = 

..
..
..
..


.
.
.
.
k(q∗p , q1 ) k(q∗p , q2 ) · · · k(q∗p , qn )
(27)
Given Q and f , f ∗ can be predicted at new ‘test locations’ Q∗ ,
using the conditional GP mean and covariance relations
f ∗ |Q∗ , Q, f ∼ N (µ(Q∗ ), σ 2 (Q∗ ))
−1

µ(Q∗ ) = K(Q∗ , Q)K(Q, Q)

(28)

f

(29)
−1

2

σ (Q∗ ) = K(Q∗ , Q∗ ) − K(Q∗ , Q)K(Q, Q)

K(Q, Q∗ )
(30)

Here, K(Q, Q∗ ) ∈ Rp×n , so that µ(Q∗ ) ∈ Rp×1 and
σ 2 (Q∗ ) ∈ Rp×p . Eq. (28) gives the expression of the conditional distribution of f ∗ given test points Q∗ , and training
data Q and f . The mean and variance of this predictive
distribution are found via Eqs. (29) and (30). In the context
of Bayesian optimization, the GP surrogate model provides
statistical information (i.e. mean and variance from 29 and
30) of how the underlying objective function y behaves for all
possible values Q∗ that have not yet been sampled.
The Mateŕn kernel is one of the most popular choices for
the kernel function k in GPBO,
!
!
√
√
3rij
3rij
kν=3/2 (xb,i , xb,j ) = σ0 1 +
exp −
,
ℓ
ℓ
(31)
q
rij = (xb,i − xb,j )T (xb,i − xb,j ), (32)

with hyperparameters σ0 and ℓ, which are the kernel amplitude
and length-scale, respectively. This kernel is guaranteed to be
k times differentiable when k ≤ ν (where ν is nearly always
taken to be half integer to simplify the kernel expression).
As is standard in GP regression, an additive observation noise
variance σn2 is also assumed for each training datum f (qi ),
where qi ∈ Q
f (qi ) = y(qi ) + ǫi ,
ǫi ∼ N (0, σn2 ),

(33)

(34)
 2
Hence, the full set of hyperparameters Θ = σn , σ0 , ℓ
governs the GP covariance function in Eq. (24).
Since the best Θ setting is not known a priori, it must be
learned and updated during GPBO. Point estimation strategies
based on maximum likelihood estimation and maximum a
posteriori estimation are the most widely used in the GPBO
literature for supervised learning of Θ [6]. Fast gradientbased convex optimization techniques are most commonly
used to minimize the negative log likelihood, since the required
derivatives can be obtained analytically. However, since the GP

likelihood is generally non-convex, numerical optimization can
converge to many different local optima for Θ. Furthermore,
the best local optimum may be undesirable for learning with
sparse data early on in the GPBO process, since the associated
Θ values typically overfit the training data [7], [4]. This
behavior is especially important to consider when trying to
minimize the number of simulations for GPBO [8].
2) The Acquisition Function: The acquisition function is
defined as the mapping a : (q, S) → R, abbreviated as
a(q) , a(q, GP(m(q), k(q, q′ )))

(35)

which assumes the inclusion of the GP surrogate model
as an argument. GPBO selects q̂ = argmaxQ a(q) as the
next location in Q to be evaluated in the search process.
Ideally, a(q) should enable exploration and modeling of y
by sampling new locations q that will improve the accuracy
of S. At the same time, a(q) must exploit S to reach the
expected minimum of y as quickly as possible. Therefore,
a(q) should not lead to greedy or myopic behavior, or get
stuck in poor local minima. There are many ways to define
a(q) to balance these needs, but the best choice is heavily
application dependent [6], [9], [10]. Some popular methods
include Expected Improvement (EI) and the Upper Confidence
Bound. We focus only on EI here, since it does not require
extra hyperparameters.
EI selects the next sample point to maximize the statistically
expected improvement in the optimum when when the current
best minimizer is q+ . The EI function is defined by [11]
(
(µ(q) − f (q+ ))Φ(Z) + σ(q)φ(Z) , σ(q) > 0
a(q) =
0
, σ(q) = 0
Z=

µ (q) − f (q+ )
,
σ(q)

where µ(q) is the mean predicted value of the GP at q and
σ(q) is the predicted standard deviation at q, f (q+ ) is the best
observed value of the objective function, and Φ(Z) and φ(Z)
are the PDF and CDF of the standard normal distribution Z.
For any definition of a(q), another optimization routine
must be used to identify the maximum of a(q) via point-based
evaluation on S. The most popular method for doing this in
GPBO is the DIviding RECTangles (DIRECT) algorithm [11],
which is a fast global non-convex optimization method that
uses the Lipschitz continuity properties of S to bound function
values in local rectangles and search accordingly for the best
local maximum of a(q). Note that the use of a non-convex
optimization technique like DIRECT makes sense here, since
they key idea behind Bayesian optimization is that evaluation
of a(q) at multiple test points q will be cheaper and faster
than evaluating y at those points directly. In this work, we use
the classical approach of selecting a single new design point
q on each iteration of GPBO, although variations to sample
multiple design points at once or repeatedly on each iteration
are also possible [8].

B. Stochastic Costs for Consistency-based Filter Auto-tuning
We now consider how y(q) can be defined via NEES and
NIS consistency test statistics for Kalman filter tuning. As
such, let Q be some space of configurable Kalman filter
parameters (e.g. the set of all parameters defining some
positive definite symmetric process noise covariance Qk ) and
let q ∈ Q be a design point.
Consider first the case of tuning based on assessment
of NEES statistics obtained via Monte Carlo ground truth
simulation models. If N Monte Carlo simulations are performed for T time steps at any given design point q, starting
from the initial conditions x̂0|0 and P0|0 , then the average
NEES statistic ǭx,k can be computed via (20) for each time
k = 1, ..., T . To summarize how ‘well-behaved’ ǭx,k is across
all time steps, we can leverage the fact that the expected value
of ǭx,k for a consistent Kalman filter ought to be nx , i.e. the
degrees of freedom of the χ2 NEES random variable (which
is the same as the number of states). We can therefore use
the following scalar function y(q) to assess how much ǭx,k
deviates from this ideal expected value across all time steps k
in N Monte Carlo truth model simulations evaluated at q,
v"
!#2
u
PT
u
ǭ
x,k
k=1
(36)
y(q) = JN EES (q) = t log
nx
By similar reasoning, we can also define
v"
!#2
u
PT
u
t
k=1 ǭz,k
log
y(q) = JN IS (q) =
.
nz

(37)

where ǭz,k could either represent NIS outcomes obtained from
truth model simulation or from a set of real data logs.
Many other possible cost functions could also be used to
summarize the behavior of the NEES/NIS statistics relative
to nx . For instance, instead of the mean over T steps, y(q)
could be defined in terms of the min/max or median of
ǭx,k or ǭz,k vs. nx over T steps. Or, y(q) could also be
based on counting the number of times ǭx,k or ǭz,k exceed
the χ2 hypothesis test bounds [l(α, N ), u(α, N )] for some
given α. While such alternative cost definitions could be
useful for different applications (say, depending on the filter
parameters being tuned), we focus on JN EES and JN IS here
for simplicity.
Algorithm 1 summarizes the GPBO procedure for Kalman
filter tuning. The termination criteria could be based on
iteration thresholds, tolerances on changes to the optimum q
and/or y between iterations, or other methods. An attractive
feature of GPBO is that eqs. 23-24 naturally provide uncertainty quantification on the shape of the objective function
at both sampled and unsampled locations. This allows GPBO
to cope with multiple local minima in the parameter space
Q. However, in practice, the GPBO’s performance depends
on the selection and parameterization of the surrogate model
kernel, as well as the number and placement of initial training
observations (i.e. seed points) to bootstrap the search process.

Algorithm 1 GPBO for Kalman Filter tuning
N

seed
1: Initialize GP with seed data {qs , ys }s=1
and hy-

perparameters Θ

2: while termination criteria not met do
3:
qj = argmaxQ a(q)

Evaluate y(qj ), e.g. using JN EES (q)
JN IS (q).
5:
Add y(qj ) to f (Q), qj to Q, and update Θ
6: end while
7: return q∗ = arg minqj ∈Q f (qj )
4:

or

IV. N UMERICAL A PPLICATION E XAMPLES
For ease of presenting the proof of concept and discussion in
this initial investigation, we restrict ourselves to an application
case study involving a simple linear time-invariant system.
However, the underlying principles apply to more complex
linear and nonlinear systems as well.
Consider a robot that moves along a 1D track and receives
position measurements every ∆t = 0.1s. Suppose the position
˙ T are governed by the linear time
and velocity state x = [ξ, ξ]
invariant kinematics model
ẋt = Axt + Gut + Γvt
zt = Hxt + wt ,
where


 


0 1
0
A=
, G=
, H= 1
0 0
1

 

0
0 , Γ=
,
1

and the inputs to the system consist of a control acceleration
ut , additive white Gaussian noise acceleration process vt with
intensity V, and additive white Gaussian position measurement noise process wt with continuous time intensity W.
The control input ut = 2 cos(0.75t) causes the robot to move
with a low frequency oscillation. Applying a zero-order hold
discretization to this system, we obtain discrete time position
and velocity state xk = [ξk , ξ̇k ]T and the linear time-invariant
parameters for eqs. (3)-(4)






1 ∆t
0.5∆t2
F=
, B=
, H= 1 0 ,
0 1
∆t

where the inputs to the system now consist of a discretized
zero-order hold control acceleration uk = 2 cos(0.075k),
additive white process noise vector vk ∈ R2 with discrete
time covariance Qk ∈ R2×2 , and additive white measurement
noise wk with discrete time covariance Rk . Note that, given
V and W, the corresponding discrete time noise covariances
are
W
,
(38)
R=
∆T
Z ∆t Z ∆t
T
Q=
eA∆t ΓVΓT eA ∆t δ(τ1 − τ2 )dτ1 dτ2 (39)
0

0

where the matrix expression for Q can be computed from A,
Γ, V, and δT using Van Loan’s method [12]. If A and Γ are
both known, then this relationship also allows us to design a

full 2 × 2 positive definite symmetric covariance matrix Q by
tuning the corresponding scalar continuous time process noise
acceleration intensity V only.
We examine GPBO-based Kalman filter tuning for the
following cases:
1) tuning of unknown Q (i.e. unknown V) with correctly
known R and known model dynamics;
2) simultaneous tuning of unknown Q and unknown R, with
correctly known model dynamics;
All results here were obtained using the open source BayesOpt
library [13] to apply the update steps and evaluate the surrogate
and acquisition functions, with the rest of the code developed
by the authors in C++.
A. Case 1: Unknown Q
In this case, q = V and the true process noise intensity for
ground truth simulations is V = 1 (m/s2 )2 /s, which results in
a true discrete time process noise covariance of


3 × 10−4 5 × 10−3
Q=
.
5 × 10−3
0.1
GPBO was used to tune the Kalman filter design by searching
over V and using (39) to construct Q, using true measurement
noise variance R = 1 m2 and the true dynamics model.
Figure 1 shows six different iterations of a NEES-based
GPBO search using the JN EES cost function over the range
V = [0, 10]. In these figures, N = 10 Monte Carlo truth model
simulations are used per JN EES evaluation, with T = 200
time steps.
The final result of this trial demonstrates that the minimum
of the surrogate function obtained through Bayesian optimization is very close to the ground truth, i.e. that V = 1. Of
particular value is also the uncertainty bounds on the surrogate
function that clearly demonstrate the uncertainty on these parameters. The figures also demonstrate a clustering of sampling
around the true minimum of the objective function, but also
a spread of samples in other places to lower uncertainty of
minima being in those regions.
B. Case 2: Unknown Q and R
In this case, GPBO was used to tune the Kalman filter
design by searching over V, Q and using (39) to construct
Q, with the noise variance R also to be estimated (cf. Case
1), while using the true dynamics model for the robot.
Figure 2 shows GPBO search using the JN EES cost function over the range V = [0, 10] in a 1-dimensional cross
section. In these figures, N = 10 Monte Carlo truth model
simulations are used per JN EES evaluation, with T = 200
time steps, just as in Case 1.
Figure 3 shows the full 2-dimensional surrogate function
after 100 iterations of Bayesian optimisation. We note that the
results for R appear more accurate than those for V, which
exhibits a large disturbance in the surrogate function near V ≈
4.5, leading to a large local minimum nearby. Inspection of
the uncertainty around the local minimum demonstrate that the
surrogate function requires more iterations to hone in on the

4

1.4

Surrogate fn
Upper uncert
Lower uncert
Sample pts

1.4

Surrogate fn
Upper uncert
Lower uncert
Sample pts

1.2

1.2

Surrogate fn
Upper uncert
Lower uncert
Sample pts

3

1
2

1

0.8

NEES

NEES

NEES

0.8

1

0.6

0

0.6
0.4

-1

0.4

0.2

0

0.2
0

1

2

3

4

5

6

7

8

9

-2
0

10

1

2

3

4

5

6

7

8

9

10

0

(a) iteration 0 (seed data)

2

3

4

6

7

8

9

10

(c) iteration 10

3.5

Surrogate fn
Upper uncert
Lower uncert
Sample pts

5

V

(b) iteration 5

3

2.5

1

V

V

6

Surrogate fn
Upper uncert
Lower uncert
Sample pts

3

Surrogate fn
Upper uncert
Lower uncert
Sample pts

5

2.5
2

4

2

NEES

NEES

3

NEES

1.5

1.5

1

2
1

0.5

1
0.5

0

0
0

-0.5

-0.5
0

1

2

3

4

5

6

7

8

9

10

-1
0

1

2

3

4

V

5

6

7

8

9

10

0

1

2

3

4

V

(d) iteration 15

5

6

7

8

9

10

V

(e) iteration 25

(f) iteration 35

Fig. 1. (a)-(f) GPBO iterations for Case 1, showing surrogate GP model (top, with sampled points, mean and 2σ bounds) and acquisition function (bottom).

2.5

Surrogate fn
Upper Uncert.
Lower Uncert.
Minimum

6

Surrogate fn
Upper uncert.
Lower uncert.
Minimum

5

2

4

1.5

NEES

NIS

3

2

1

1
0.5

0

0

-1
0

1

2

3

4

5

6

7

8

9

10

V

(a) NEES results

0

1

2

3

4

5

6

7

8

9

10

V

(b) NIS results

Fig. 2. Case 2, showing surrogate GP model with sampled points, mean and 2σ bounds after 100 iterations of GPBO: (a) NEES results; (b) NIS results.

global minimum. Fig. 4 shows estimates of the path overlaid
on the ground truth path in state space, demonstrating that
the two local minima are surprisingly close to one another
and underscoring the need for a global optimizer that outputs
information on the various optima present in parameter space.
V. C ONCLUSIONS AND F UTURE W ORK
In this work we have developed a new approach to tuning
Kalman filters which lead to optimal estimates on the filter
parameters, and have demonstrated the method’s success on
the case of a single-dof robot in simulation. We have shown
that the uncertainty estimates resulting from the use of this
method are both a valuable addition to the classical optimization pipeline but also an important point of consideration for
determining the dependability of its results.
In the future the authors will extend this work by turning
to other estimation problems, including sensor calibration parameters for e.g. visual simultaneous localization and mapping.
This will require the extension of the method to more complex
linear and non-linear system models, as well as demonstrating
its effectiveness with real hardware and experimental data.
There is also a wealth of experimentation to be conducted in

the study of other cost functions, acquisition functions, kernels,
and parameterizations. Furthermore, so-called “pre-whitening”
filters might be leveraged to possibly speed the convergence of
GPBO to accommodate non-white noise processes, and other
optimization methods besides DIRECT might improve the
estimate of the global optimum once the method has reached a
certain threshold. Finally, GPBO will be evaluated against alternative auto-tuning approaches, such as maximum likelihood
estimation using expectation maximization [5], online adaptive
noise covariance estimation, [14], [15], reinforcement learning
[16], and simplex-based optimization [17].
R EFERENCES
[1] R. E. Kalman and R. S. Bucy, “New results in linear filtering and
prediction theory,” Journal of Basic Engineering, vol. 83, no. 1, pp.
95–108, 1961.
[2] Y. Bar-Shalom, X. Li, and T.Kirubarajan, Estimation with Applications
to Navigation and Tracking. New York: Wiley, 2001.
[3] R. F. Stengel, Optimal control and estimation. Courier Corporation,
1986.
[4] C. E. Rasmussen and C. K. I. Williams, Gaussian processes for machine
learning, ser. Adaptive computation and machine learning. Cambridge,
Mass: MIT Press, 2006.
[5] C. M. Bishop, Pattern recognition and machine learning. New York:
Springer, 2006.

Surrogate fn
Minimum

7

7

6

6

5

5

4

4

NIS

NEES

Surrogate fn
Minimum

3
2

3
2

1

1

0
10

0
10
8
6
4
2

R

0

0

1

2

6

5

4

3

7

9

8

8

10

6
4
2

R

V

0

(a) NEES results

0

1

4

3

2

6

5

7

8

9

10

V

(b) NIS results

Fig. 3. Case 2, showing surrogate GP model with sampled points, mean and 2σ bounds after 100 iterations of GPBO, for both V and R values. (a) shows
the NEES results, while (b) shows the NIS results.

4

8

simulator
estimator

simulator
estimator

6
3

4

2
2

1

velocity

velocity

0

-2

0

-4
-1

-6

-2
-8

-10
-20

-3
-15

-10

-5

0

5

10

0

2

4

6

position

8

10

12

position

(a) R = 4.623, V = 0.001

(b) R = 3.925, V = 0.587

4

simulator
estimator
3

2

velocity

1

0

-1

-2

-3

-4
-2

0

2

4

6

8

10

12

position

(c) R = 1.063, V = 1.000
Fig. 4. Case 2 ξ vs. ξ̇ plots of the system dynamics overlaid with the estimated path from the Kalman filter.

[6] B. Shahriari, K. Swersky, Z. Wang, R. P. Adams, and N. de Freitas,
“Taking the Human Out of the Loop: A Review of Bayesian Optimization,” Proceedings of the IEEE, vol. 104, 2016.
[7] G. C. Cawley and N. L. C. Talbot, “Preventing Over-Fitting during
Model Selection via Bayesian Regularisation of the Hyper-Parameters,”
Journal of Machine Learning Research, vol. 8, pp. 841–861, 2007.
[8] B. Israelsen, N. Ahmed, K. Center, R. Green, and W. B. Jr., “Adaptive
simulation-based training of artificial-intelligence decision makers using
Bayesian optimization,” Journal of Aerospace Information Systems,
vol. 15, no. 2, pp. 38–56, 2018.
[9] E. Brochu, V. M. Cora, and N. L. B. B. De Freitas, “A tutorial on
Bayesian optimization of expensive cost functions, with application to
active user modeling and hierarchical reinforcement learning,” arXiv
preprint arXiv:1012.2599, 2010.
[10] M. Hoffman, E. Brochu, and N. D. Freitas, “Portfolio Allocation
for Bayesian Optimization,” Conference on Uncertainty in Artificial
Intelligence, pp. 327–336, 2011.
[11] D. R. Jones, M. Schonlau, and J. William, “Efficient Global Optimization
of Expensive Black-Box Functions,” Journal of Global Optimization,
vol. 13, no. 4, pp. 455–492, 1998.

[12] R. G. Brown and P. Y. Hwang, Introduction to random signals and
applied Kalman filtering: with MATLAB exercises. J. Wiley & Sons,
2012.
[13] R. Martinez-Cantin, “BayesOpt: A Bayesian optimization library for
nonlinear optimization, experimental design and bandits,” in Journal of
Machine Learning Research, 2014, pp. 3735–3739.
[14] S.
Akhlaghi,
N.
Zhou,
and
Z.
Huang,
“Parallel
Bayesian
Global
Optimization
of
Expensive
Functions,”
arXiv preprint:1702.00884, Feb 2017. [Online]. Available:
https://arxiv.org/ftp/arxiv/papers/1702/1702.00884.pdf
[15] P. S. Maybeck, R. L. Jensen, and D. A. Harnly, “An adaptive extended
Kalman filter for target image tracking,” IEEE Trans. on Aero. and Elec.
Sys., vol. AES-17, no. 2, pp. 173–180, March 1981.
[16] C. Goodall and N. El-Sheimy, “Intelligent tuning of a Kalman filter using
low-cost MEMS inertial sensors,” in Proceedings of 5th International
Symposium on Mobile Mapping Technology (MMT07), Padua, Italy,
2007, pp. 1–8.
[17] T. D. Powell, “Automated tuning of an extended Kalman filter using
the downhill simplex algorithm,” Journal of Guidance, Control, and
Dynamics, vol. 25, no. 5, pp. 901–908, 2002.

